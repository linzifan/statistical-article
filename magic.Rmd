---
title: "Magic Square"
author: "Zifan Lin"
date: "March 9, 2015"
output: html_document
---

A magic square is an arrangement of distinct integers in a square grid, where the numbers in each row, and in each column, and the numbers in the main and secondary diagonals, all add up to the same number. Normal magic squares of all sizes except $n=2$ can be constructed.

Here I will write functions to construct magic squares of all orders using the following three algorithm. Notice that the magic square of some order is not unique. Here these algorithms could give one solution, but not give all possible solutions.

- **odd order $n = 2M + 1$**

The method prescribes starting in the central column of the first row `i <- 1; j <- (n + 1) / 2` with number 1. After that, the fundamental movement for filling the squares is diagonally right and up `i <- i - 1; j <- j + 1`, one step at a time. If it moves beyond the right boundary, continue from the left side `j <- j - n`; if it moves beyond the top, continue from the bottom `i <- i + n`. If a filled square is encountered, one move vertically up one square instead `i <- i + 2; j <- j - 1`, then continue as before.

```{r}
magic_2Mp1 <- function(n, echo=FALSE){
  # n must be the odd number
  if (n %% 2 == 0) warning("To use this method, n must be the odd number") 
  else {result <- matrix(0, nrow = n, ncol = n)       
        i <- 1
        j <- (n + 1) / 2
        result[i,j] <- 1
        for (k in 2:n^2){
          i <- i - 1
          j <- j + 1
          if (i <= 0) i <- i + n
          if (j > n) j <- j - n
          if (result[i, j] > 0) {
            i <- i + 2
            j <- j - 1
            if (i > n) i <- i - n
            if (j <= 0) j <- j + n
          }
          result[i, j] <- k
        }
        Sum <- (n^2 + 1) / 2 * n
        # check the row sum and column sum
        if(all(colSums(result) == Sum) & all(rowSums(result) == Sum)) {
          if(echo){
            cat("Magic square found at the order of", n, "\n")
            print(result)
            cat("Row sum and column sum are both", Sum, "\n")
          }
          return(result)
        }        
  }
}

magic.9 <- magic_2Mp1(9, echo=T)
```


- **doubly even order $n = 4M$**

All numbers are written in order from left to right across each row in turn, starting from the top left corner. Numbers are then either retained in the same place or interchanged with their diametrically opposite numbers in a certain regular pattern. In the situation of order of 4, those numbers on the diagonal and anti-diagonal are retained, while other numbers are interchanged. In the situation of order more than 4 (8, 12, and so on), first divide the grid into several $4 \times 4$ squares, retain the numbers on those diagonals and anti-diagonals, while other numbers are interchanged. Another way to understand how to interchange numbers with their diametrically opposite numbers is that to select numbers from the square where the numbers are written in reverse order to fill in the blanks which are not on the diagonals and anti-diagonals.

```{r}
magic_4M <- function(n, echo=FALSE){
  # n must be the integer divisible by 4
  if (n %% 4 != 0) warning("To use this method, n must be the integer divisible by 4") 
  else {temp0 <- diag(nrow = 4, ncol = 4) + diag(nrow = 4, ncol = 4)[, 4:1]
        temp1 <- temp0
        m <- n/4
        if (m > 1){
          for (i in 2:m){temp1 <- cbind(temp1, temp0)}
          temp0 <- temp1
          for (i in 2:m){temp1 <- rbind(temp1, temp0)}
        }
        temp2 <- matrix(rep(1, n^2), nrow = n, ncol = n) - temp1 
        result <- matrix(1:n^2, nrow = n, ncol = n, byrow = T) * temp1 + 
                  matrix(n^2:1, nrow = n, ncol = n, byrow = T) * temp2
        Sum <- (n^2 + 1) / 2 * n
        # check the row sum and column sum
        if(all(colSums(result) == Sum) & all(rowSums(result) == Sum)) {
          if(echo){
            cat("Magic square found at the order of", n, "\n")
            print(result)
            cat("Row sum and column sum are both", Sum, "\n")
          }
          return(result)
        }        
  }
}

magic.8 <- magic_4M(8, echo=T)
```


- **$n = 4M + 2$**


